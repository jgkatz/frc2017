// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.Behemoth;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;

import java.io.Serializable;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.CANSpeedController.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.VictorSP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Encoder driveTraindriveTrainEncoder;
    public static Compressor driveTrainCompressor;
    public static DoubleSolenoid driveTrainshiftingSol;
    public static SpeedController driveTrainLFMotor;
    public static SpeedController driveTrainLRMotor;
    public static SpeedController driveTrainRFMotor;
    public static SpeedController driveTrainRRMotor;
    public static RobotDrive driveTrainRobotDrive41;
    public static Encoder flyWheelflywheelQuad;
    public static CANTalon flyWheelflywheelMasterMotor;
    public static CANTalon flyWheelflywheelSlaveMotor;
    public static AnalogPotentiometer hoodhoodPotentiometer;
    public static CANTalon hoodhoodMotor;
    public static AnalogPotentiometer turntableturnTablePot;
    public static DigitalInput turntableLimitProx;
    public static CANTalon turntableturnTableMotor;
    public static CANTalon intakeintake;
    public static CANTalon indexerIndexerMaster;
    public static CANTalon indexerIndexerSlave;
    public static DoubleSolenoid winchptoSol;
    public static DoubleSolenoid winchClimbBarSol;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static ADXRS450_Gyro gyro;

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTraindriveTrainEncoder = new Encoder(8, 9, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveTrain", "driveTrainEncoder", driveTraindriveTrainEncoder);
        driveTraindriveTrainEncoder.setDistancePerPulse(1.0);
        driveTraindriveTrainEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        driveTrainCompressor = new Compressor(0);
        
        
        driveTrainshiftingSol = new DoubleSolenoid(0, 0, 1);
        LiveWindow.addActuator("DriveTrain", "shiftingSol", driveTrainshiftingSol);
        
        driveTrainLFMotor = new VictorSP(0);
        LiveWindow.addActuator("DriveTrain", "LFMotor", (VictorSP) driveTrainLFMotor);
        
        driveTrainLRMotor = new VictorSP(1);
        LiveWindow.addActuator("DriveTrain", "LRMotor", (VictorSP) driveTrainLRMotor);
        
        driveTrainRFMotor = new VictorSP(2);
        LiveWindow.addActuator("DriveTrain", "RFMotor", (VictorSP) driveTrainRFMotor);
        
        driveTrainRRMotor = new VictorSP(3);
        LiveWindow.addActuator("DriveTrain", "RRMotor", (VictorSP) driveTrainRRMotor);
        
        driveTrainRobotDrive41 = new RobotDrive(driveTrainLFMotor, driveTrainLRMotor,
              driveTrainRFMotor, driveTrainRRMotor);
        
        driveTrainRobotDrive41.setSafetyEnabled(false);
        driveTrainRobotDrive41.setExpiration(0.1);
        driveTrainRobotDrive41.setSensitivity(0.5);
        driveTrainRobotDrive41.setMaxOutput(1.0);
        driveTrainRobotDrive41.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
        driveTrainRobotDrive41.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        driveTrainRobotDrive41.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        driveTrainRobotDrive41.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        flyWheelflywheelQuad = new Encoder(6, 7, false, EncodingType.k4X);
        LiveWindow.addSensor("FlyWheel", "flywheelQuad", flyWheelflywheelQuad);
        flyWheelflywheelQuad.setDistancePerPulse(0.0038759689);
        flyWheelflywheelQuad.setPIDSourceType(PIDSourceType.kRate);
        flyWheelflywheelMasterMotor = new CANTalon(10);
        LiveWindow.addActuator("FlyWheel", "flywheelMasterMotor", flyWheelflywheelMasterMotor);
        
        flyWheelflywheelSlaveMotor = new CANTalon(11);
        LiveWindow.addActuator("FlyWheel", "flywheelSlaveMotor", flyWheelflywheelSlaveMotor);
        
        hoodhoodPotentiometer = new AnalogPotentiometer(0, 360.0, 0.0);
        LiveWindow.addSensor("Hood", "hoodPotentiometer", hoodhoodPotentiometer);
        
        hoodhoodMotor = new CANTalon(8);
        LiveWindow.addActuator("Hood", "hoodMotor", hoodhoodMotor);
        
        turntableturnTablePot = new AnalogPotentiometer(1, 360.0, 0.0);
        LiveWindow.addSensor("Turntable", "turnTablePot", turntableturnTablePot);
        
        turntableLimitProx = new DigitalInput(0);
        LiveWindow.addSensor("Turntable", "LimitProx", turntableLimitProx);
        
        turntableturnTableMotor = new CANTalon(6);
        LiveWindow.addActuator("Turntable", "turnTableMotor", turntableturnTableMotor);
        
        intakeintake = new CANTalon(5);
        LiveWindow.addActuator("Intake", "intake", intakeintake);
        
        indexerIndexerMaster = new CANTalon(7);
        LiveWindow.addActuator("Indexer", "IndexerMaster", indexerIndexerMaster);
        
        indexerIndexerSlave = new CANTalon(9);
        LiveWindow.addActuator("Indexer", "IndexerSlave", indexerIndexerSlave);
        
        winchptoSol = new DoubleSolenoid(0, 2, 3);
        LiveWindow.addActuator("Winch", "ptoSol", winchptoSol);
        
        winchClimbBarSol = new DoubleSolenoid(0, 6, 7);
        LiveWindow.addActuator("Winch", "ClimbBarSol", winchClimbBarSol);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        // This is the gyro we will be using this year, it is plugged directly into the roborio, though we should try and keep
        // it as close to center as possible.
        gyro = new ADXRS450_Gyro();
        
        // This is the only time that we will ever talk to these two motors, hence the reason that they are called
        // "slaves." From the moment that the roborio is enabled, they will be watching their respective masters, and doing exactly
        // what they are doing at any given point in time.
        //((CANTalon) indexerIndexerSlave).changeControlMode(TalonControlMode.Follower);
        ((CANTalon) flyWheelflywheelSlaveMotor).changeControlMode(TalonControlMode.Follower);
    }
}
