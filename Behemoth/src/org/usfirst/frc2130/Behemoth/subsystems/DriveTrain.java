// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.Behemoth.subsystems;

import org.usfirst.frc2130.Behemoth.RobotMap;
import org.usfirst.frc2130.Behemoth.commands.*;
import org.usfirst.frc2130.Behemoth.Robot;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Victor;

import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class DriveTrain extends PIDSubsystem {
	
	public double distanceA = 3000, // These are the set of distances that the robot needs to go for autonomous. We
									// will find their actual values when we tune the competition drive train.
				  distanceB = 2000,
				  distanceC = 4000,
				  differenceA, // We will take our robot's position at whatever time is considered present, and subtract
				  			   // that value from where we want to be. The resultant difference is assigned to the variable
				  			   // distance.
				  differenceB,
				  differenceC,
				  proA, // After we have calculated our difference from our desired headings, we will then multiply the value
				  		// by our "ap" variable, giving us a proportional rate of turn.
				  		// For example, 		120 - 100 = 20			40 * 0.4 = 0.8 or 80% motor power.
				  proB,
				  proC,
				  headingA = 120, // The desired headings that our robot is trying to reach using the gryo that is 
				  				  // attached to the roborio.
				  headingB = 200,
				  headingC = 250,
				  tolerance = 2, // The amount of error that the gyro considers acceptable. Under current conditions,
				  				 // it will consider any degree + or - 2 of its desired heading to be acceptable, and stop
				  				 // trying to reach said degree if is within the range.
				 
				  ap = 0.4, // These are the values by which we divide the calculated differences in order to get proportional
				  			// decreases in power, based on distance from the target, for our motors.
				  bp = 0.05,
				  z = 1,
				  n;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Encoder driveTrainEncoder = RobotMap.driveTraindriveTrainEncoder;
    private final Compressor compressor = RobotMap.driveTrainCompressor;
    private final DoubleSolenoid shiftingSol = RobotMap.driveTrainshiftingSol;
    private final SpeedController lFMotor = RobotMap.driveTrainLFMotor;
    private final SpeedController lRMotor = RobotMap.driveTrainLRMotor;
    private final SpeedController rFMotor = RobotMap.driveTrainRFMotor;
    private final SpeedController rRMotor = RobotMap.driveTrainRRMotor;
    private final RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("DriveTrain", 0.01, 0.0, 0.0);
        setAbsoluteTolerance(15.0);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("DriveTrain", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new shiftToHighGear());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return driveTrainEncoder.pidGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }

    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        lFMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    }
    
    // Drive Train Encoder
    
    	// Returns the value of our encoder in a non-decimal number.
    	public int readTheEncoder() {
    		return driveTrainEncoder.get();
   		}
    
    	// Will be used to start the encoder every time that the robot is enabled.
    	public void resetTheEncoder() {
    		driveTrainEncoder.reset();
    	}
    
    // Drive Train Gyro
    
    	// When this is activated, the robot CAN NOT be moving. It will take 5 seconds for it to complete the calibration
    	// cycle, so its best not to do this during a match if we can help it.
    	public void resetTheGyro() {
    		RobotMap.gyro.reset();
    	}
    
    	// Returns the value of the gryo in a decimal format.
    	public double readTheGyro() {
    		return RobotMap.gyro.getAngle();
    	}
    
    // Motor Control Functions
    
    	// Gives us the value of the motors on the left side of our robot. These will be applied to the right side of the robot,
    	// which will be helpful during autonomous when we are moving with the encoders.
    	public double motorValue() {
    		return lFMotor.get() * -1;
    	}
    	
    	// Uses the above calculated speed of the left side motors and applies an equal power setting to the motors on the right,
    	// mostly useful for us during auto.
    	public void setRightSideMotors() {
    		rRMotor.set(motorValue());
    		rFMotor.set(motorValue());
    		lRMotor.set(motorValue() * -1);
    	}
    
    	// Sets the drive train to full stop.
    	public void stopTheDriveTrain() {
    		lFMotor.stopMotor();
    		lRMotor.stopMotor();
    		rFMotor.stopMotor();
    		rRMotor.stopMotor();
    	}
    
    	// This allows the drive to run the robot using a joystick.
    	public void joystickDriveTrain() {
    		robotDrive41.arcadeDrive(Robot.oi.driverJoy.getRawAxis(1), 
    				                 Robot.oi.driverJoy.getRawAxis(4));
    	}
    
    // Drivetrain Calculations For Auto
    
    	// For the following three commands, we subtract our current heading from our desired heading, and apply that value to the
    	// difference variable. 
    	public double calDifA() {
    		differenceA = readTheGyro() - headingA;
    		return differenceA;
    	}
    
    	public double calDifB() {
    		differenceB = readTheGyro() - headingB;
    		return differenceB;
    	}
    
    	public double calDifC() {
    		differenceC = readTheGyro() - headingC;
    		return differenceC;
    	}
    
    	// For the following three commands, we multiply the difference between our desired heading and our current heading.
    	// This value is then multiplied by a decimal variable, and applied later as the power setting for our motor. This means
    	// that the closer we get to our desired heading, the slower our robot will move, ensuring that we have a smooth rate of 
    	// turn. This value will then be applied to the ProA variable.
    	public double proportionalA() {
    		proA = calDifA() * ap;
    		return proA;
    	}
    
    	public double proportionalB() {
    		proB = calDifB() * ap;
    		return proB;
    	}
    
    	public double proportionalC() {
    		proC = calDifC() * ap;
    		return proC;
    	}
    
    // Drivetrain Gyro PID Calculator And Headings

    	// This takes a given target, be it any of our headings, and subtracts that target
    	// from our current gyro heading. If this error is greater than our predefined tolerance for the error, it will
    	// multiply it by bp, and set that as the motor value. It will run the motor through the "P" portion of a PID loop.
    	public double controller(double target) {
    		double error = (target - readTheGyro());
    		if (Math.abs(error) > tolerance) {
    			return error * bp;
    		}
    		else {
    			return 0.0;
    		}
    	}
    	
    	// This sets the output of our robot and slows it down to about one-half of its speed, because a fast rate
    	// of turn could affect the accuracy of our gyro. 
    	public void setWithSaturate(double desiredOutput) {
    		double limitedOutput = desiredOutput;
    		rFMotor.set(limitedOutput * 0.5);
    		rRMotor.set(limitedOutput * 0.5);
    		lFMotor.set(limitedOutput * 0.5);
    		lRMotor.set(limitedOutput * 0.5);
    	}
    
    	// All three of the following commands are called throughout our autonomous code. They run all of the
    	// above calculations and find / hold headings. In order to change headings, simply change the variable name for each
    	// heading above.
    	public void goToHeadingA() {
    		double desiredOutput = controller(headingA);
    		setWithSaturate(desiredOutput);
    	}
    
    	public void goToHeadingB() {
    		double desiredOutput = controller(headingB);
    		setWithSaturate(desiredOutput);
    	}
    
    	public void goToHeadingC() {
    		double desiredOutput = controller(headingC);
    		setWithSaturate(desiredOutput);
    	}
    
    // Shifting Pnuematics
    
    	// These commands are used to shift to either high or low gear.
    	public void shiftToLowGear() {
    		shiftingSol.set(Value.kForward);
    	}
    
    	public void shiftToHighGear() {
    		shiftingSol.set(Value.kReverse);
    	}
    	
    // Climbing Control Loops
    	
    	public void runTheWinch() {
    		if (Robot.oi.driverJoy.getRawAxis(3) == 1){
    			robotDrive41.drive(1, 0);
    		}
    	}
}
